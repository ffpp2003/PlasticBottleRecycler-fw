                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.4.0 #14620 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module hr4988
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _TIM2_ITConfig
                                     12 	.globl _TIM2_Cmd
                                     13 	.globl _TIM2_TimeBaseInit
                                     14 	.globl _TIM1_SetCompare2
                                     15 	.globl _TIM1_OC2PreloadConfig
                                     16 	.globl _TIM1_ARRPreloadConfig
                                     17 	.globl _TIM1_CtrlPWMOutputs
                                     18 	.globl _TIM1_Cmd
                                     19 	.globl _TIM1_OC2Init
                                     20 	.globl _TIM1_TimeBaseInit
                                     21 	.globl _GPIO_ReadOutputData
                                     22 	.globl _GPIO_WriteLow
                                     23 	.globl _GPIO_WriteHigh
                                     24 	.globl _GPIO_Write
                                     25 	.globl _GPIO_Init
                                     26 	.globl _CLK_PeripheralClockConfig
                                     27 	.globl _hr4988_init
                                     28 	.globl _hr4988_setSpeed
                                     29 	.globl _hr4988_setSteps
                                     30 	.globl _hr4988_setRotation
                                     31 	.globl _hr4988_setStepMode
                                     32 	.globl _hr4988_setStepper
                                     33 ;--------------------------------------------------------
                                     34 ; ram data
                                     35 ;--------------------------------------------------------
                                     36 	.area DATA
      000000                         37 _currentSpeed:
      000000                         38 	.ds 2
      000002                         39 _rotationChange:
      000002                         40 	.ds 1
      000003                         41 _stepperState:
      000003                         42 	.ds 1
      000004                         43 _rotation:
      000004                         44 	.ds 1
      000005                         45 _desiredSpeed:
      000005                         46 	.ds 2
      000007                         47 _stepperService_update_10000_401:
      000007                         48 	.ds 4
      00000B                         49 _changeRotation_deaccelPasses_10000_404:
      00000B                         50 	.ds 1
                                     51 ;--------------------------------------------------------
                                     52 ; ram data
                                     53 ;--------------------------------------------------------
                                     54 	.area INITIALIZED
      000000                         55 _stepMode:
      000000                         56 	.ds 1
      000001                         57 _stepsPerRevolution:
      000001                         58 	.ds 2
                                     59 ;--------------------------------------------------------
                                     60 ; absolute external ram data
                                     61 ;--------------------------------------------------------
                                     62 	.area DABS (ABS)
                                     63 
                                     64 ; default segment ordering for linker
                                     65 	.area HOME
                                     66 	.area GSINIT
                                     67 	.area GSFINAL
                                     68 	.area CONST
                                     69 	.area INITIALIZER
                                     70 	.area CODE
                                     71 
                                     72 ;--------------------------------------------------------
                                     73 ; global & static initialisations
                                     74 ;--------------------------------------------------------
                                     75 	.area HOME
                                     76 	.area GSINIT
                                     77 	.area GSFINAL
                                     78 	.area GSINIT
                                     79 ;	../hr4988.c: 101: static uint32_t update = 0;
      000000 5F               [ 1]   80 	clrw	x
      000001 CFu00u09         [ 2]   81 	ldw	_stepperService_update_10000_401+2, x
      000004 CFu00u07         [ 2]   82 	ldw	_stepperService_update_10000_401+0, x
                                     83 ;	../hr4988.c: 120: static bool deaccelPasses = 0;
      000007 72 5Fu00u0B      [ 1]   84 	clr	_changeRotation_deaccelPasses_10000_404+0
                                     85 ;--------------------------------------------------------
                                     86 ; Home
                                     87 ;--------------------------------------------------------
                                     88 	.area HOME
                                     89 	.area HOME
                                     90 ;--------------------------------------------------------
                                     91 ; code
                                     92 ;--------------------------------------------------------
                                     93 	.area CODE
                                     94 ;	../hr4988.c: 22: void hr4988_init(void){
                                     95 ;	-----------------------------------------
                                     96 ;	 function hr4988_init
                                     97 ;	-----------------------------------------
      000000                         98 _hr4988_init:
                                     99 ;	../hr4988.c: 23: GPIO_Init(STEPPER_GPIO, STEPPER_MS1 | STEPPER_MS2 | STEPPER_MS3 | STEPPER_ENA | STEPPER_DIR | STEPPER_SLP | STEPPER_STP, GPIO_MODE_OUT_PP_LOW_FAST);
      000000 4B E0            [ 1]  100 	push	#0xe0
      000002 A6 FE            [ 1]  101 	ld	a, #0xfe
      000004 AE 50 0A         [ 2]  102 	ldw	x, #0x500a
      000007 CDr00r00         [ 4]  103 	call	_GPIO_Init
                                    104 ;	../hr4988.c: 24: GPIO_WriteLow(STEPPER_GPIO, STEPPER_MS1 | STEPPER_MS2 | STEPPER_MS3 | STEPPER_ENA);
      00000A A6 F0            [ 1]  105 	ld	a, #0xf0
      00000C AE 50 0A         [ 2]  106 	ldw	x, #0x500a
      00000F CDr00r00         [ 4]  107 	call	_GPIO_WriteLow
                                    108 ;	../hr4988.c: 25: GPIO_WriteHigh(STEPPER_GPIO, STEPPER_SLP);
      000012 A6 08            [ 1]  109 	ld	a, #0x08
      000014 AE 50 0A         [ 2]  110 	ldw	x, #0x500a
      000017 CDr00r00         [ 4]  111 	call	_GPIO_WriteHigh
                                    112 ;	../hr4988.c: 27: CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER1, ENABLE);
      00001A 4B 01            [ 1]  113 	push	#0x01
      00001C A6 07            [ 1]  114 	ld	a, #0x07
      00001E CDr00r00         [ 4]  115 	call	_CLK_PeripheralClockConfig
                                    116 ;	../hr4988.c: 28: TIM1_PWM_Init(100);
      000021 AE 00 64         [ 2]  117 	ldw	x, #0x0064
      000024 CDr00rAC         [ 4]  118 	call	_TIM1_PWM_Init
                                    119 ;	../hr4988.c: 29: TIM2_INT_Init();
                                    120 ;	../hr4988.c: 30: }
      000027 CCr00r89         [ 2]  121 	jp	_TIM2_INT_Init
                                    122 ;	../hr4988.c: 32: void hr4988_setSpeed(uint16_t rpm){
                                    123 ;	-----------------------------------------
                                    124 ;	 function hr4988_setSpeed
                                    125 ;	-----------------------------------------
      00002A                        126 _hr4988_setSpeed:
                                    127 ;	../hr4988.c: 33: desiredSpeed = rpm;
      00002A CFu00u05         [ 2]  128 	ldw	_desiredSpeed+0, x
                                    129 ;	../hr4988.c: 34: }
      00002D 81               [ 4]  130 	ret
                                    131 ;	../hr4988.c: 36: void hr4988_setSteps(uint16_t steps){
                                    132 ;	-----------------------------------------
                                    133 ;	 function hr4988_setSteps
                                    134 ;	-----------------------------------------
      00002E                        135 _hr4988_setSteps:
                                    136 ;	../hr4988.c: 37: stepsPerRevolution = steps;
      00002E CFu00u01         [ 2]  137 	ldw	_stepsPerRevolution+0, x
                                    138 ;	../hr4988.c: 38: }
      000031 81               [ 4]  139 	ret
                                    140 ;	../hr4988.c: 40: void hr4988_setRotation(rotation_t rot){
                                    141 ;	-----------------------------------------
                                    142 ;	 function hr4988_setRotation
                                    143 ;	-----------------------------------------
      000032                        144 _hr4988_setRotation:
                                    145 ;	../hr4988.c: 41: if (rot != rotation) {
      000032 C1u00u04         [ 1]  146 	cp	a, _rotation+0
      000035 26 01            [ 1]  147 	jrne	00113$
      000037 81               [ 4]  148 	ret
      000038                        149 00113$:
                                    150 ;	../hr4988.c: 42: rotation = rot;
      000038 C7u00u04         [ 1]  151 	ld	_rotation+0, a
                                    152 ;	../hr4988.c: 43: rotationChange = 1;
      00003B 35 01u00u02      [ 1]  153 	mov	_rotationChange+0, #0x01
                                    154 ;	../hr4988.c: 45: }
      00003F 81               [ 4]  155 	ret
                                    156 ;	../hr4988.c: 47: void hr4988_setStepMode(stepMode_t mode){
                                    157 ;	-----------------------------------------
                                    158 ;	 function hr4988_setStepMode
                                    159 ;	-----------------------------------------
      000040                        160 _hr4988_setStepMode:
      000040 88               [ 1]  161 	push	a
      000041 C7u00u00         [ 1]  162 	ld	_stepMode+0, a
                                    163 ;	../hr4988.c: 49: GPIO_Write(STEPPER_GPIO, GPIO_ReadOutputData(STEPPER_GPIO) & ~(STEPPER_MS1 | STEPPER_MS2 | STEPPER_MS3) | 
      000044 AE 50 0A         [ 2]  164 	ldw	x, #0x500a
      000047 CDr00r00         [ 4]  165 	call	_GPIO_ReadOutputData
      00004A A4 8F            [ 1]  166 	and	a, #0x8f
      00004C 6B 01            [ 1]  167 	ld	(0x01, sp), a
                                    168 ;	../hr4988.c: 50: ((stepMode >> 2) & 0x01) << STEPPER_MS3_PINN |
      00004E C6u00u00         [ 1]  169 	ld	a, _stepMode+0
      000051 44               [ 1]  170 	srl	a
      000052 44               [ 1]  171 	srl	a
      000053 A4 01            [ 1]  172 	and	a, #0x01
      000055 4E               [ 1]  173 	swap	a
      000056 A4 F0            [ 1]  174 	and	a, #0xf0
      000058 1A 01            [ 1]  175 	or	a, (0x01, sp)
      00005A 6B 01            [ 1]  176 	ld	(0x01, sp), a
                                    177 ;	../hr4988.c: 51: ((stepMode >> 1) & 0x01) << STEPPER_MS2_PINN |
      00005C C6u00u00         [ 1]  178 	ld	a, _stepMode+0
      00005F 44               [ 1]  179 	srl	a
      000060 A4 01            [ 1]  180 	and	a, #0x01
      000062 4E               [ 1]  181 	swap	a
      000063 A4 F0            [ 1]  182 	and	a, #0xf0
      000065 48               [ 1]  183 	sll	a
      000066 1A 01            [ 1]  184 	or	a, (0x01, sp)
      000068 6B 01            [ 1]  185 	ld	(0x01, sp), a
                                    186 ;	../hr4988.c: 52: ((stepMode) & 0x01) << STEPPER_MS1_PINN
      00006A C6u00u00         [ 1]  187 	ld	a, _stepMode+0
      00006D A4 01            [ 1]  188 	and	a, #0x01
      00006F 4E               [ 1]  189 	swap	a
      000070 A4 F0            [ 1]  190 	and	a, #0xf0
      000072 48               [ 1]  191 	sll	a
      000073 48               [ 1]  192 	sll	a
      000074 1A 01            [ 1]  193 	or	a, (0x01, sp)
                                    194 ;	../hr4988.c: 49: GPIO_Write(STEPPER_GPIO, GPIO_ReadOutputData(STEPPER_GPIO) & ~(STEPPER_MS1 | STEPPER_MS2 | STEPPER_MS3) | 
      000076 AE 50 0A         [ 2]  195 	ldw	x, #0x500a
      000079 5B 01            [ 2]  196 	addw	sp, #1
      00007B CCr00r00         [ 2]  197 	jp	_GPIO_Write
                                    198 ;	../hr4988.c: 54: }
      00007E 84               [ 1]  199 	pop	a
      00007F 81               [ 4]  200 	ret
                                    201 ;	../hr4988.c: 56: void hr4988_setStepper(FunctionalState state){
                                    202 ;	-----------------------------------------
                                    203 ;	 function hr4988_setStepper
                                    204 ;	-----------------------------------------
      000080                        205 _hr4988_setStepper:
                                    206 ;	../hr4988.c: 57: TIM1_CtrlPWMOutputs(state);
      000080 88               [ 1]  207 	push	a
      000081 CDr00r00         [ 4]  208 	call	_TIM1_CtrlPWMOutputs
      000084 84               [ 1]  209 	pop	a
                                    210 ;	../hr4988.c: 58: stepperState = state;
      000085 C7u00u03         [ 1]  211 	ld	_stepperState+0, a
                                    212 ;	../hr4988.c: 59: }
      000088 81               [ 4]  213 	ret
                                    214 ;	../hr4988.c: 62: void TIM2_INT_Init(void) {
                                    215 ;	-----------------------------------------
                                    216 ;	 function TIM2_INT_Init
                                    217 ;	-----------------------------------------
      000089                        218 _TIM2_INT_Init:
                                    219 ;	../hr4988.c: 63: CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER2, ENABLE);
      000089 4B 01            [ 1]  220 	push	#0x01
      00008B A6 05            [ 1]  221 	ld	a, #0x05
      00008D CDr00r00         [ 4]  222 	call	_CLK_PeripheralClockConfig
                                    223 ;	../hr4988.c: 64: TIM2_TimeBaseInit(TIM2_PRESCALER_16, 49);
      000090 AE 00 31         [ 2]  224 	ldw	x, #0x0031
      000093 A6 04            [ 1]  225 	ld	a, #0x04
      000095 CDr00r00         [ 4]  226 	call	_TIM2_TimeBaseInit
                                    227 ;	../hr4988.c: 65: TIM2_InterruptCallback = stepperService;
      000098 AEr01r76         [ 2]  228 	ldw	x, #(_stepperService+0)
      00009B CFu00u00         [ 2]  229 	ldw	_TIM2_InterruptCallback+0, x
                                    230 ;	../hr4988.c: 66: TIM2_ITConfig(TIM2_IT_UPDATE, ENABLE);
      00009E 4B 01            [ 1]  231 	push	#0x01
      0000A0 A6 01            [ 1]  232 	ld	a, #0x01
      0000A2 CDr00r00         [ 4]  233 	call	_TIM2_ITConfig
                                    234 ;	../hr4988.c: 67: TIM2_Cmd(ENABLE);
      0000A5 A6 01            [ 1]  235 	ld	a, #0x01
      0000A7 CDr00r00         [ 4]  236 	call	_TIM2_Cmd
                                    237 ;	../hr4988.c: 68: enableInterrupts();
      0000AA 9A               [ 1]  238 	rim
                                    239 ;	../hr4988.c: 69: }
      0000AB 81               [ 4]  240 	ret
                                    241 ;	../hr4988.c: 71: void TIM1_PWM_Init(uint16_t frequency) {
                                    242 ;	-----------------------------------------
                                    243 ;	 function TIM1_PWM_Init
                                    244 ;	-----------------------------------------
      0000AC                        245 _TIM1_PWM_Init:
      0000AC 52 04            [ 2]  246 	sub	sp, #4
                                    247 ;	../hr4988.c: 72: uint16_t prescaler = (F_CPU / frequency) / 65536;
      0000AE 1F 03            [ 2]  248 	ldw	(0x03, sp), x
      0000B0 90 93            [ 1]  249 	ldw	y, x
      0000B2 5F               [ 1]  250 	clrw	x
      0000B3 90 89            [ 2]  251 	pushw	y
      0000B5 89               [ 2]  252 	pushw	x
      0000B6 4B 00            [ 1]  253 	push	#0x00
      0000B8 4B 24            [ 1]  254 	push	#0x24
      0000BA 4B F4            [ 1]  255 	push	#0xf4
      0000BC 4B 00            [ 1]  256 	push	#0x00
      0000BE CDr00r00         [ 4]  257 	call	__divslong
      0000C1 5B 08            [ 2]  258 	addw	sp, #8
      0000C3 4B 00            [ 1]  259 	push	#0x00
      0000C5 4B 00            [ 1]  260 	push	#0x00
      0000C7 4B 01            [ 1]  261 	push	#0x01
      0000C9 4B 00            [ 1]  262 	push	#0x00
      0000CB 89               [ 2]  263 	pushw	x
      0000CC 90 89            [ 2]  264 	pushw	y
      0000CE CDr00r00         [ 4]  265 	call	__divslong
      0000D1 5B 08            [ 2]  266 	addw	sp, #8
                                    267 ;	../hr4988.c: 73: uint16_t arr = (F_CPU / (frequency * (prescaler + 1))) - 1;
      0000D3 1F 01            [ 2]  268 	ldw	(0x01, sp), x
      0000D5 5C               [ 1]  269 	incw	x
      0000D6 16 03            [ 2]  270 	ldw	y, (0x03, sp)
      0000D8 89               [ 2]  271 	pushw	x
      0000D9 93               [ 1]  272 	ldw	x, y
      0000DA CDr00r00         [ 4]  273 	call	__mulint
      0000DD 90 5F            [ 1]  274 	clrw	y
      0000DF 89               [ 2]  275 	pushw	x
      0000E0 90 89            [ 2]  276 	pushw	y
      0000E2 4B 00            [ 1]  277 	push	#0x00
      0000E4 4B 24            [ 1]  278 	push	#0x24
      0000E6 4B F4            [ 1]  279 	push	#0xf4
      0000E8 4B 00            [ 1]  280 	push	#0x00
      0000EA CDr00r00         [ 4]  281 	call	__divslong
      0000ED 5B 08            [ 2]  282 	addw	sp, #8
      0000EF 5A               [ 2]  283 	decw	x
                                    284 ;	../hr4988.c: 75: TIM1_TimeBaseInit(prescaler, TIM1_COUNTERMODE_UP, arr, 0);
      0000F0 89               [ 2]  285 	pushw	x
      0000F1 4B 00            [ 1]  286 	push	#0x00
      0000F3 89               [ 2]  287 	pushw	x
      0000F4 4F               [ 1]  288 	clr	a
      0000F5 1E 06            [ 2]  289 	ldw	x, (0x06, sp)
      0000F7 CDr00r00         [ 4]  290 	call	_TIM1_TimeBaseInit
      0000FA 85               [ 2]  291 	popw	x
                                    292 ;	../hr4988.c: 80: (arr + 1) / 2,
      0000FB 5C               [ 1]  293 	incw	x
      0000FC 54               [ 2]  294 	srlw	x
                                    295 ;	../hr4988.c: 77: TIM1_OCMODE_PWM1,
      0000FD 4B 00            [ 1]  296 	push	#0x00
      0000FF 4B 00            [ 1]  297 	push	#0x00
      000101 4B 00            [ 1]  298 	push	#0x00
      000103 4B 00            [ 1]  299 	push	#0x00
      000105 89               [ 2]  300 	pushw	x
      000106 4B 00            [ 1]  301 	push	#0x00
      000108 4B 11            [ 1]  302 	push	#0x11
      00010A A6 60            [ 1]  303 	ld	a, #0x60
      00010C CDr00r00         [ 4]  304 	call	_TIM1_OC2Init
                                    305 ;	../hr4988.c: 87: TIM1_OC2PreloadConfig(ENABLE); // Habilitar pre-carga para CCR2
      00010F A6 01            [ 1]  306 	ld	a, #0x01
      000111 CDr00r00         [ 4]  307 	call	_TIM1_OC2PreloadConfig
                                    308 ;	../hr4988.c: 88: TIM1_ARRPreloadConfig(ENABLE);
      000114 A6 01            [ 1]  309 	ld	a, #0x01
      000116 CDr00r00         [ 4]  310 	call	_TIM1_ARRPreloadConfig
                                    311 ;	../hr4988.c: 89: TIM1_Cmd(ENABLE);
      000119 A6 01            [ 1]  312 	ld	a, #0x01
      00011B 5B 04            [ 2]  313 	addw	sp, #4
                                    314 ;	../hr4988.c: 90: }
      00011D CCr00r00         [ 2]  315 	jp	_TIM1_Cmd
                                    316 ;	../hr4988.c: 92: void TIM1_SetFrequency(uint16_t frequency) {
                                    317 ;	-----------------------------------------
                                    318 ;	 function TIM1_SetFrequency
                                    319 ;	-----------------------------------------
      000120                        320 _TIM1_SetFrequency:
      000120 52 04            [ 2]  321 	sub	sp, #4
                                    322 ;	../hr4988.c: 93: uint16_t prescaler = (F_CPU / frequency) / 65536;
      000122 1F 03            [ 2]  323 	ldw	(0x03, sp), x
      000124 90 93            [ 1]  324 	ldw	y, x
      000126 5F               [ 1]  325 	clrw	x
      000127 90 89            [ 2]  326 	pushw	y
      000129 89               [ 2]  327 	pushw	x
      00012A 4B 00            [ 1]  328 	push	#0x00
      00012C 4B 24            [ 1]  329 	push	#0x24
      00012E 4B F4            [ 1]  330 	push	#0xf4
      000130 4B 00            [ 1]  331 	push	#0x00
      000132 CDr00r00         [ 4]  332 	call	__divslong
      000135 5B 08            [ 2]  333 	addw	sp, #8
      000137 4B 00            [ 1]  334 	push	#0x00
      000139 4B 00            [ 1]  335 	push	#0x00
      00013B 4B 01            [ 1]  336 	push	#0x01
      00013D 4B 00            [ 1]  337 	push	#0x00
      00013F 89               [ 2]  338 	pushw	x
      000140 90 89            [ 2]  339 	pushw	y
      000142 CDr00r00         [ 4]  340 	call	__divslong
      000145 5B 08            [ 2]  341 	addw	sp, #8
                                    342 ;	../hr4988.c: 94: uint16_t arr = (F_CPU / (frequency * (prescaler + 1))) - 1;
      000147 1F 01            [ 2]  343 	ldw	(0x01, sp), x
      000149 5C               [ 1]  344 	incw	x
      00014A 16 03            [ 2]  345 	ldw	y, (0x03, sp)
      00014C 89               [ 2]  346 	pushw	x
      00014D 93               [ 1]  347 	ldw	x, y
      00014E CDr00r00         [ 4]  348 	call	__mulint
      000151 90 5F            [ 1]  349 	clrw	y
      000153 89               [ 2]  350 	pushw	x
      000154 90 89            [ 2]  351 	pushw	y
      000156 4B 00            [ 1]  352 	push	#0x00
      000158 4B 24            [ 1]  353 	push	#0x24
      00015A 4B F4            [ 1]  354 	push	#0xf4
      00015C 4B 00            [ 1]  355 	push	#0x00
      00015E CDr00r00         [ 4]  356 	call	__divslong
      000161 5B 08            [ 2]  357 	addw	sp, #8
      000163 5A               [ 2]  358 	decw	x
                                    359 ;	../hr4988.c: 96: TIM1_TimeBaseInit(prescaler, TIM1_COUNTERMODE_UP, arr, 0);
      000164 89               [ 2]  360 	pushw	x
      000165 4B 00            [ 1]  361 	push	#0x00
      000167 89               [ 2]  362 	pushw	x
      000168 4F               [ 1]  363 	clr	a
      000169 1E 06            [ 2]  364 	ldw	x, (0x06, sp)
      00016B CDr00r00         [ 4]  365 	call	_TIM1_TimeBaseInit
      00016E 85               [ 2]  366 	popw	x
                                    367 ;	../hr4988.c: 97: TIM1_SetCompare2((arr + 1) / 2);
      00016F 5C               [ 1]  368 	incw	x
      000170 54               [ 2]  369 	srlw	x
      000171 5B 04            [ 2]  370 	addw	sp, #4
                                    371 ;	../hr4988.c: 98: }
      000173 CCr00r00         [ 2]  372 	jp	_TIM1_SetCompare2
                                    373 ;	../hr4988.c: 100: void stepperService(void) {
                                    374 ;	-----------------------------------------
                                    375 ;	 function stepperService
                                    376 ;	-----------------------------------------
      000176                        377 _stepperService:
                                    378 ;	../hr4988.c: 103: if (update >= 1000){
      000176 CEu00u09         [ 2]  379 	ldw	x, _stepperService_update_10000_401+2
      000179 A3 03 E8         [ 2]  380 	cpw	x, #0x03e8
      00017C C6u00u08         [ 1]  381 	ld	a, _stepperService_update_10000_401+1
      00017F A2 00            [ 1]  382 	sbc	a, #0x00
      000181 C6u00u07         [ 1]  383 	ld	a, _stepperService_update_10000_401+0
      000184 A2 00            [ 1]  384 	sbc	a, #0x00
      000186 25 3D            [ 1]  385 	jrc	00111$
                                    386 ;	../hr4988.c: 104: if (rotationChange)
      000188 72 01u00u02 03   [ 2]  387 	btjf	_rotationChange+0, #0, 00102$
                                    388 ;	../hr4988.c: 105: changeRotation();
      00018D CDr01rDB         [ 4]  389 	call	_changeRotation
      000190                        390 00102$:
                                    391 ;	../hr4988.c: 107: if (currentSpeed < desiredSpeed)
      000190 CEu00u05         [ 2]  392 	ldw	x, _desiredSpeed+0
      000193 C3u00u00         [ 2]  393 	cpw	x, _currentSpeed+0
      000196 23 09            [ 2]  394 	jrule	00106$
                                    395 ;	../hr4988.c: 108: currentSpeed++;
      000198 CEu00u00         [ 2]  396 	ldw	x, _currentSpeed+0
      00019B 5C               [ 1]  397 	incw	x
      00019C CFu00u00         [ 2]  398 	ldw	_currentSpeed+0, x
      00019F 20 0F            [ 2]  399 	jra	00107$
      0001A1                        400 00106$:
                                    401 ;	../hr4988.c: 109: else if (currentSpeed > desiredSpeed)
      0001A1 CEu00u05         [ 2]  402 	ldw	x, _desiredSpeed+0
      0001A4 C3u00u00         [ 2]  403 	cpw	x, _currentSpeed+0
      0001A7 24 07            [ 1]  404 	jrnc	00107$
                                    405 ;	../hr4988.c: 110: currentSpeed--;
      0001A9 CEu00u00         [ 2]  406 	ldw	x, _currentSpeed+0
      0001AC 5A               [ 2]  407 	decw	x
      0001AD CFu00u00         [ 2]  408 	ldw	_currentSpeed+0, x
      0001B0                        409 00107$:
                                    410 ;	../hr4988.c: 112: if (currentSpeed != desiredSpeed)
      0001B0 CEu00u05         [ 2]  411 	ldw	x, _desiredSpeed+0
      0001B3 C3u00u00         [ 2]  412 	cpw	x, _currentSpeed+0
      0001B6 27 06            [ 1]  413 	jreq	00109$
                                    414 ;	../hr4988.c: 113: setSpeed(currentSpeed);
      0001B8 CEu00u00         [ 2]  415 	ldw	x, _currentSpeed+0
      0001BB CDr02r1C         [ 4]  416 	call	_setSpeed
      0001BE                        417 00109$:
                                    418 ;	../hr4988.c: 114: update = 0;
      0001BE 5F               [ 1]  419 	clrw	x
      0001BF CFu00u09         [ 2]  420 	ldw	_stepperService_update_10000_401+2, x
      0001C2 CFu00u07         [ 2]  421 	ldw	_stepperService_update_10000_401+0, x
      0001C5                        422 00111$:
                                    423 ;	../hr4988.c: 116: update += 50;
      0001C5 CEu00u09         [ 2]  424 	ldw	x, _stepperService_update_10000_401+2
      0001C8 1C 00 32         [ 2]  425 	addw	x, #0x0032
      0001CB 90 CEu00u07      [ 2]  426 	ldw	y, _stepperService_update_10000_401+0
      0001CF 24 02            [ 1]  427 	jrnc	00156$
      0001D1 90 5C            [ 1]  428 	incw	y
      0001D3                        429 00156$:
      0001D3 CFu00u09         [ 2]  430 	ldw	_stepperService_update_10000_401+2, x
      0001D6 90 CFu00u07      [ 2]  431 	ldw	_stepperService_update_10000_401+0, y
                                    432 ;	../hr4988.c: 117: }
      0001DA 81               [ 4]  433 	ret
                                    434 ;	../hr4988.c: 119: void changeRotation(void){
                                    435 ;	-----------------------------------------
                                    436 ;	 function changeRotation
                                    437 ;	-----------------------------------------
      0001DB                        438 _changeRotation:
                                    439 ;	../hr4988.c: 121: if (deaccelPasses | !stepperState){
      0001DB C6u00u03         [ 1]  440 	ld	a, _stepperState+0
      0001DE A8 01            [ 1]  441 	xor	a, #0x01
      0001E0 CAu00u0B         [ 1]  442 	or	a, _changeRotation_deaccelPasses_10000_404+0
      0001E3 27 20            [ 1]  443 	jreq	00108$
                                    444 ;	../hr4988.c: 122: if (rotation == CLKWISE)
      0001E5 72 00u00u04 0A   [ 2]  445 	btjt	_rotation+0, #0, 00102$
                                    446 ;	../hr4988.c: 123: GPIO_WriteLow(STEPPER_GPIO, STEPPER_DIR);
      0001EA A6 02            [ 1]  447 	ld	a, #0x02
      0001EC AE 50 0A         [ 2]  448 	ldw	x, #0x500a
      0001EF CDr00r00         [ 4]  449 	call	_GPIO_WriteLow
      0001F2 20 08            [ 2]  450 	jra	00103$
      0001F4                        451 00102$:
                                    452 ;	../hr4988.c: 125: GPIO_WriteHigh(STEPPER_GPIO, STEPPER_DIR);
      0001F4 A6 02            [ 1]  453 	ld	a, #0x02
      0001F6 AE 50 0A         [ 2]  454 	ldw	x, #0x500a
      0001F9 CDr00r00         [ 4]  455 	call	_GPIO_WriteHigh
      0001FC                        456 00103$:
                                    457 ;	../hr4988.c: 126: rotationChange = 0;
      0001FC 72 5Fu00u02      [ 1]  458 	clr	_rotationChange+0
                                    459 ;	../hr4988.c: 127: deaccelPasses = 0;
      000200 72 5Fu00u0B      [ 1]  460 	clr	_changeRotation_deaccelPasses_10000_404+0
      000204 81               [ 4]  461 	ret
      000205                        462 00108$:
                                    463 ;	../hr4988.c: 129: if (currentSpeed >= 5)
      000205 CEu00u00         [ 2]  464 	ldw	x, _currentSpeed+0
      000208 A3 00 05         [ 2]  465 	cpw	x, #0x0005
      00020B 25 0A            [ 1]  466 	jrc	00105$
                                    467 ;	../hr4988.c: 130: currentSpeed -= 3;
      00020D CEu00u00         [ 2]  468 	ldw	x, _currentSpeed+0
      000210 1D 00 03         [ 2]  469 	subw	x, #0x0003
      000213 CFu00u00         [ 2]  470 	ldw	_currentSpeed+0, x
      000216 81               [ 4]  471 	ret
      000217                        472 00105$:
                                    473 ;	../hr4988.c: 132: deaccelPasses = 1;
      000217 35 01u00u0B      [ 1]  474 	mov	_changeRotation_deaccelPasses_10000_404+0, #0x01
                                    475 ;	../hr4988.c: 134: }
      00021B 81               [ 4]  476 	ret
                                    477 ;	../hr4988.c: 136: void setSpeed(uint16_t speed){
                                    478 ;	-----------------------------------------
                                    479 ;	 function setSpeed
                                    480 ;	-----------------------------------------
      00021C                        481 _setSpeed:
                                    482 ;	../hr4988.c: 137: TIM1_SetFrequency((speed/stepsPerRevolution)*60);
      00021C 90 CEu00u01      [ 2]  483 	ldw	y, _stepsPerRevolution+0
      000220 65               [ 2]  484 	divw	x, y
      000221 89               [ 2]  485 	pushw	x
      000222 AE 00 3C         [ 2]  486 	ldw	x, #0x003c
      000225 CDr00r00         [ 4]  487 	call	__mulint
                                    488 ;	../hr4988.c: 138: }
      000228 CCr01r20         [ 2]  489 	jp	_TIM1_SetFrequency
                                    490 	.area CODE
                                    491 	.area CONST
                                    492 	.area INITIALIZER
      000000                        493 __xinit__stepMode:
      000000 04                     494 	.db #0x04	; 4
      000001                        495 __xinit__stepsPerRevolution:
      000001 00 32                  496 	.dw #0x0032
                                    497 	.area CABS (ABS)
